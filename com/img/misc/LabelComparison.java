package com.img.misc;

import java.awt.image.BufferedImage;
import java.awt.image.WritableRaster;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashSet;
import java.util.Set;

import javax.imageio.ImageIO;



public class LabelComparison {
	public static void main(String[] args) throws IOException{
		Set<Character> class_of_interest=new HashSet<>();
		class_of_interest.add('B'); //I am only interested in airplane, so only 'B' is in the set.
		//You may want to add other classes, the classes not in the set will be treated as background.
		Path ground_truth_folder=Paths.get("D:/VOCdevkit/VOC2012/SegmentationClass");		
		Path predict_img_folder=Paths.get("D:/ImgPix/hmmGMM4_12/TestImg");//folder of images generated by the model
		int[] total_accuracy={0,0,0};
		try(DirectoryStream<Path> dir=Files.newDirectoryStream(predict_img_folder)){
		  for(Path predict_img_path: dir){	
			  
		   try(InputStream ground=Files.newInputStream(ground_truth_folder.resolve(predict_img_path.getFileName()));
			 InputStream result=Files.newInputStream(predict_img_path)){
			 BufferedImage ground_Image=ImageIO.read(ground);
			 BufferedImage predict_Image=ImageIO.read(result);
			 int[] accuracy=compareImg(ground_Image, predict_Image, class_of_interest);
			 System.out.println(((double)accuracy[0])/accuracy[1]);
			 total_accuracy[0]+=accuracy[0];
			 total_accuracy[1]+=accuracy[1];
			 total_accuracy[2]+=accuracy[2];
		    }
		  }
		}
		System.out.println("Overall:");
		System.out.println(((double)total_accuracy[0])/total_accuracy[1]);
		System.out.println("Background :");
		System.out.println(((double)total_accuracy[2])/total_accuracy[1]);
	}
	
	public static int[] compareImg(BufferedImage ground_truth, BufferedImage predict, Set<Character> class_of_interest){ 
		int count=0;
		int correct=0;
		int background=0;
		WritableRaster ground = ground_truth.getRaster();
		WritableRaster prediction = predict.getRaster();
		for(int y=0; y<ground_truth.getHeight(); y++){
			for(int x=0; x<ground_truth.getWidth(); x++ ){
				char truth_class=getClass(ground, x, y, ground_truth.getType());
				if(truth_class=='Z')
					continue;
				char prediction_class=getClass(prediction, x, y, predict.getType());
				if(!class_of_interest.contains(prediction_class))
					prediction_class='A';
				if(!class_of_interest.contains(truth_class))
					truth_class='A';
				count++;
				if(truth_class==prediction_class)
					correct++;
				if(truth_class=='A')
					background++;
			}
		}
		int[] output={correct, count, background};
		return output;
	
	}

	private static char getClass(WritableRaster prediction, int x, int y, int type) {
		// TODO Auto-generated method stub
		int[] colorarray=new int[3];
		
		prediction.getPixel(x, y, colorarray);
		if(type==5){
			if (colorarray[0]==0 && colorarray[1]==0 && colorarray[2]==0)
     		    return 'A';
    		else if (colorarray[0]==128 && colorarray[1]==0 && colorarray[2]==0)
    			return 'B';
    		else if (colorarray[0]==0 && colorarray[1]==128 && colorarray[2]==0)
    			return 'C';
    		else if (colorarray[0]==128 && colorarray[1]==128 && colorarray[2]==0)
    			return 'D';
    		else if (colorarray[0]==0 && colorarray[1]==0 && colorarray[2]==128)
    			return 'E';
    		else if (colorarray[0]==128 && colorarray[1]==0 && colorarray[2]==128)
    			return 'F';
    		else if (colorarray[0]==0 && colorarray[1]==128 && colorarray[2]==128)
    			return 'G';
    		else if (colorarray[0]==128 && colorarray[1]==128 && colorarray[2]==128)
    			return 'H';
    		else if (colorarray[0]==64 && colorarray[1]==0 && colorarray[2]==0)
    			return 'I';
    		else if (colorarray[0]==192 && colorarray[1]==0 && colorarray[2]==0)
    			return 'J';
    		else if (colorarray[0]==64 && colorarray[1]==128 && colorarray[2]==0)
    			return 'K';
    		else if (colorarray[0]==192 && colorarray[1]==128 && colorarray[2]==0)
    			return 'L';
    		else if (colorarray[0]==64 && colorarray[1]==0 && colorarray[2]==128)
    			return 'M';
    		else if (colorarray[0]==192 && colorarray[1]==0 && colorarray[2]==128)
    			return 'N';
    		else if (colorarray[0]==64 && colorarray[1]==128 && colorarray[2]==128)
    			return 'O';
    		else if (colorarray[0]==192 && colorarray[1]==128 && colorarray[2]==128)
    			return 'P';
    		else if (colorarray[0]==0 && colorarray[1]==64 && colorarray[2]==0)
    			return 'Q';
    		else if (colorarray[0]==128 && colorarray[1]==64 && colorarray[2]==0)
    			return 'R';
    		else if (colorarray[0]==0 && colorarray[1]==192 && colorarray[2]==0)
    			return 'S';
    		else if (colorarray[0]==128 && colorarray[1]==192 && colorarray[2]==0)
    			return 'T';
    		else if (colorarray[0]==0 && colorarray[1]==64 && colorarray[2]==128)
    			return 'U';
    		else
    			return 'Z';
		}else{
			switch(colorarray[0]){
			case 0: return 'A';
			case 1: return 'B';
			case 2: return 'C';
			case 3: return 'D';
			case 4: return 'E';
			case 5: return 'F';
			case 6: return 'G';
			case 7: return 'H';
			case 8: return 'I';
			case 9: return 'J';
			case 10: return 'K';
			case 11: return 'L';
			case 12: return 'M';
			case 13: return 'N';
			case 14: return 'O';
			case 15: return 'P';
			case 16: return 'Q';
			case 17: return 'R';
			case 18: return 'S';
			case 19: return 'T';
			case 20: return 'U';
			default: return 'Z';
			}
		}
		
		
	}

}
